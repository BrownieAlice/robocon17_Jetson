#include "ros/ros.h"
#include "detect_cercle/MBinput.h"
#include "../include/uart_setting.h"
#include "../include/uart.cpp"
#include "MB_uart_communication.h"
#include <stdint.h>

int main(int argc,char **argv){
  ros::init(argc,argv,"MB_uart_communication");
  ros::NodeHandle n;
  ros::Publisher MBdata_pub = n.advertise<detect_cercle::MBinput>("MBdata", 5);

  try_connect_MB();

  while(ros::ok()){
    ros::Rate loop_rate(main_loop_hz);
    int8_t MB_pole=0,color=0;
    float x=0,y=0,theta=0;
    bool success=false;
    
    get_uart_input(&MB_pole,&color,&x,&y,&theta,&success);
    publish_MBdata(MB_pole,color,x,y,theta,success,MBdata_pub);
 
    //loop_rate.sleep();
    }
}

void try_connect_MB(void){
  /*
    シリアルポートをオープンできなければ周波数 connect_loop_hz で再試行し続ける.
   */
  int open_success;
  open_success=open_serial_port(serial_dev);
  ros::Rate loop_rate(connect_loop_hz);
  while(-1==open_success){
    ROS_INFO("fail to open serial port.");
    ROS_INFO("try %dHz to open serial port.\n",connect_loop_hz);
    open_success=open_serial_port(serial_dev);
    loop_rate.sleep();
  }
}

void get_uart_input(int8_t *MB_pole,int8_t *color,float *x,float *y,float *theta,bool *success){
  if('X'==get_serial_char()){
    const unsigned char n=get_serial_char();
    *MB_pole=(int8_t)n;
    const unsigned char c=get_serial_char();
    *color=(int8_t)c;
    const unsigned char xl=get_serial_char();
    const unsigned char xh=get_serial_char();
    *x=(float)((int16_t)(xl|xh<<8))/1000;
    const unsigned char yl=get_serial_char();
    const unsigned char yh=get_serial_char();
    *y=(float)((int16_t)(yl|yh<<8))/1000;
    const unsigned char tl=get_serial_char();
    const unsigned char th=get_serial_char();
    const int theta_i=(int)((int16_t)(tl|th<<8));
    *theta=(float)theta_i/100.0/180*M_PI;
    const unsigned char calc_sum=n+c+xl+xh+yl+yh+tl+th;
    const unsigned char calc_val=get_serial_char();

    if(calc_val!=calc_sum){
      ROS_INFO("checksum is invalid\n");
      *success=false;
    }
    else{
      *success=true;
    }
  }
}

void publish_MBdata(int8_t MB_pole,int8_t color,float x,float y,float theta,bool success,ros::Publisher MBdata_pub){
  if(success){
    detect_cercle::MBinput MBinfo;
    
    MBinfo.MB_pole=MB_pole;
    MBinfo.color=color;
    MBinfo.x=x;
    MBinfo.y=y;
    MBinfo.theta=theta;
    MBinfo.get_time=ros::Time::now();
    
    MBdata_pub.publish(MBinfo);
    ROS_INFO("MBdata::MB_pole:%d,color:%d,x:%f,y:%f,theta:%f\n",(int)MB_pole,(int)color,x,y,theta);
  } 
}
