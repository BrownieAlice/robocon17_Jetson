#include <ros/ros.h>
#include <visualization_msgs/Marker.h>
#include <sensor_msgs/LaserScan.h>
#include <cmath>
#include <cstdlib>
#include "my_def.h"
#include "write_line.h"
#include "write_line.cpp"
#include "line_detect_cuda.h"

namespace{
  const float theta_min=0,theta_max=PI,theta_wid=0.01,rho_min=-5,rho_max=5,rho_wid=0.01;
  const int theta_num=(int)((theta_max-theta_min)/theta_wid),rho_num=(int)((rho_max-rho_min)/rho_wid);
  const int lrf_begin=100,lrf_end=LRF_DATA-100;
  const int near_theta=5,near_rho=10,thr=20;
}

void Laser_Callback(const sensor_msgs::LaserScan& msg);

int main( int argc, char** argv )
{
  ros::init(argc, argv, "points_and_lines");
  ros::NodeHandle node;
  ros::Subscriber laser;
  ros::Publisher marker_pub = node.advertise<visualization_msgs::Marker>("visualization_marker", 10);
  laser = node.subscribe("scan",2,Laser_Callback);
  ros::spin();
}


void Laser_Callback(const sensor_msgs::LaserScan& msg){
  const int start=ros::Time::now().nsec;
  float ranges[LRF_DATA];
  for(int i=0;i<LRF_DATA;i++)ranges[i]=(float)msg.ranges[i];
  line_detect_cuda(ranges,lrf_begin,lrf_end,msg.angle_increment,msg.angle_min,theta_min,theta_wid,theta_num,rho_min,rho_wid,rho_num,near_theta,near_rho,thr);
  printf("\n");
  const int end=ros::Time::now().nsec;
  printf("time:%d\n",(end-start)/1000000);
}
